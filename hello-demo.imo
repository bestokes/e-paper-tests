/**
 * ESP32 7.5b e-Paper Display Demo
 * Displays "HELLO" on Waveshare 7.5b e-Paper display
 * Single file for Arduino IDE flashing
 */

// SPI pin definitions for ESP32
#define PIN_SPI_SCK  13
#define PIN_SPI_DIN  14
#define PIN_SPI_CS   15
#define PIN_SPI_BUSY 25
#define PIN_SPI_RST  26
#define PIN_SPI_DC   27

// Pin level definitions
#define LOW             0
#define HIGH            1
#define GPIO_PIN_SET   1
#define GPIO_PIN_RESET 0

// Type definitions
typedef unsigned char UBYTE;
typedef unsigned int UWORD;

// Display resolution for 7.5b
#define EPD_WIDTH  800
#define EPD_HEIGHT 480

// Look-up tables for 7.5b V2 display
UBYTE Voltage_Frame_7IN5_V2[] = {
  0x6, 0x3F, 0x3F, 0x11, 0x24, 0x7, 0x17,
};

UBYTE LUT_VCOM_7IN5_V2[] = {  
  0x0,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x0,  0xF,  0x1,  0xF,  0x1,  0x2,  
  0x0,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
};            

UBYTE LUT_WW_7IN5_V2[] = {  
  0x10,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x84,  0xF,  0x1,  0xF,  0x1,  0x2,  
  0x20,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
};

UBYTE LUT_BW_7IN5_V2[] = {  
  0x10,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x84,  0xF,  0x1,  0xF,  0x1,  0x2,  
  0x20,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
};

UBYTE LUT_WB_7IN5_V2[] = {  
  0x80,  0xF,  0xF,  0x0,  0x0,  0x3,  
  0x84,  0xF,  0x1,  0xF,  0x1,  0x4,  
  0x40,  0xF,  0xF,  0x0,  0x0,  0x3,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
};

UBYTE LUT_BB_7IN5_V2[] = {  
  0x80,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x84,  0xF,  0x1,  0xF,  0x1,  0x2,  
  0x40,  0xF,  0xF,  0x0,  0x0,  0x1,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  
};

// Function prototypes
void EPD_initSPI();
void GPIO_Mode(unsigned char GPIO_Pin, unsigned char Mode);
void EpdSpiTransferCallback(UBYTE data);
void EPD_SendCommand(UBYTE command);
void EPD_SendData(UBYTE data);
void EPD_WaitUntilIdle();
void EPD_Reset();
static void EPD_7in5_V2_Readbusy();
static void EPD_7IN5_V2_LUT(UBYTE* lut_vcom, UBYTE* lut_ww, UBYTE* lut_bw, UBYTE* lut_wb, UBYTE* lut_bb);
int EPD_7in5B_V2_Init();
static void EPD_7IN5_V2_Show();
void clearDisplay();

// Initialize SPI pins
void EPD_initSPI() {
    pinMode(PIN_SPI_BUSY, INPUT);
    pinMode(PIN_SPI_RST, OUTPUT);
    pinMode(PIN_SPI_DC, OUTPUT);
    
    pinMode(PIN_SPI_SCK, OUTPUT);
    pinMode(PIN_SPI_DIN, OUTPUT);
    pinMode(PIN_SPI_CS, OUTPUT);

    digitalWrite(PIN_SPI_CS, HIGH);
    digitalWrite(PIN_SPI_SCK, LOW);
}

// Set GPIO pin mode
void GPIO_Mode(unsigned char GPIO_Pin, unsigned char Mode) {
    if(Mode == 0) {
        pinMode(GPIO_Pin, INPUT);
    } else {
        pinMode(GPIO_Pin, OUTPUT);
    }
}

// SPI transfer function
void EpdSpiTransferCallback(UBYTE data) {
    digitalWrite(PIN_SPI_CS, GPIO_PIN_RESET);

    for (int i = 0; i < 8; i++) {
        if ((data & 0x80) == 0) digitalWrite(PIN_SPI_DIN, GPIO_PIN_RESET); 
        else                    digitalWrite(PIN_SPI_DIN, GPIO_PIN_SET);

        data <<= 1;
        digitalWrite(PIN_SPI_SCK, GPIO_PIN_SET);
        digitalWrite(PIN_SPI_SCK, GPIO_PIN_RESET);
    }
    
    digitalWrite(PIN_SPI_CS, GPIO_PIN_SET);
}

// Send command to display
void EPD_SendCommand(UBYTE command) {
    digitalWrite(PIN_SPI_DC, LOW);
    EpdSpiTransferCallback(command);
}

// Send data to display
void EPD_SendData(UBYTE data) {
    digitalWrite(PIN_SPI_DC, HIGH);
    EpdSpiTransferCallback(data);
}

// Wait until display is not busy
void EPD_WaitUntilIdle() {
    while(digitalRead(PIN_SPI_BUSY) == 0) delay(100);    
}

// Reset display
void EPD_Reset() {
    digitalWrite(PIN_SPI_RST, HIGH); 
    delay(200);    
    digitalWrite(PIN_SPI_RST, LOW);    
    delay(5);
    digitalWrite(PIN_SPI_RST, HIGH); 
    delay(200);    
}

// Read busy state for V2 display
static void EPD_7in5_V2_Readbusy() {
    Serial.print("\r\ne-Paper busy\r\n");
    unsigned char busy;
    do {
        EPD_SendCommand(0x71);
        busy = digitalRead(PIN_SPI_BUSY);
        busy =!(busy & 0x01);        
    } while(busy);   
    delay(200);      
    Serial.print("e-Paper busy release\r\n");
}

// Load LUT data
static void EPD_7IN5_V2_LUT(UBYTE* lut_vcom, UBYTE* lut_ww, UBYTE* lut_bw, UBYTE* lut_wb, UBYTE* lut_bb) {
    UBYTE count;

    EPD_SendCommand(0x20); // VCOM    
    for(count = 0; count < 60; count++)
        EPD_SendData(lut_vcom[count]);

    EPD_SendCommand(0x21); // LUTWW
    for(count = 0; count < 60; count++)
        EPD_SendData(lut_ww[count]);

    EPD_SendCommand(0x22); // LUTBW
    for(count = 0; count < 60; count++)
        EPD_SendData(lut_bw[count]);

    EPD_SendCommand(0x23); // LUTWB
    for(count = 0; count < 60; count++)
        EPD_SendData(lut_wb[count]);

    EPD_SendCommand(0x24); // LUTBB
    for(count = 0; count < 60; count++)
        EPD_SendData(lut_bb[count]);
}

// Initialize 7.5b V2 display
int EPD_7in5B_V2_Init() {
    EPD_Reset();

    EPD_SendCommand(0x01);            // POWER SETTING
    EPD_SendData(0x07);
    EPD_SendData(0x07);               // VGH=20V,VGL=-20V
    EPD_SendData(0x3f);               // VDH=15V
    EPD_SendData(0x3f);               // VDL=-15V

    EPD_SendCommand(0x04);            // POWER ON
    delay(100);
    EPD_7in5_V2_Readbusy();

    EPD_SendCommand(0X00);            // PANNEL SETTING
    EPD_SendData(0x0F);               // KW-3f   KWR-2F BWROTP 0f BWOTP 1f

    EPD_SendCommand(0x61);            // tres
    EPD_SendData(0x03);               // source 800
    EPD_SendData(0x20);
    EPD_SendData(0x01);               // gate 480
    EPD_SendData(0xE0);

    EPD_SendCommand(0X15);
    EPD_SendData(0x00);

    EPD_SendCommand(0X50);            // VCOM AND DATA INTERVAL SETTING
    EPD_SendData(0x11);
    EPD_SendData(0x07);

    EPD_SendCommand(0X60);            // TCON SETTING
    EPD_SendData(0x22);

    EPD_SendCommand(0x65);            // Resolution setting
    EPD_SendData(0x00);
    EPD_SendData(0x00);               // 800*480
    EPD_SendData(0x00);
    EPD_SendData(0x00);
    
    UWORD i;
    EPD_SendCommand(0x10);            // First buffer (black)
    for(i = 0; i < EPD_WIDTH / 8 * EPD_HEIGHT; i++) {
        EPD_SendData(0x00);
    }
    
    EPD_SendCommand(0x13);            // Second buffer (red)
    for(i = 0; i < EPD_WIDTH / 8 * EPD_HEIGHT; i++) {
        EPD_SendData(0x00);
    }

    EPD_SendCommand(0x10);            // Switch back to first buffer
    return 0;
}

// Show display and enter sleep mode
static void EPD_7IN5_V2_Show() {
    EPD_SendCommand(0x12);            // DISPLAY REFRESH
    delay(100);                       // Delay necessary, 200uS at least
    EPD_7in5_V2_Readbusy();

    // Enter sleep mode
    EPD_SendCommand(0X02);            // power off
    EPD_7in5_V2_Readbusy();
    EPD_SendCommand(0X07);            // deep sleep
    EPD_SendData(0xA5);
}

// Clear display (fill with white)
void clearDisplay() {
    EPD_SendCommand(0x10);  // Black buffer
    for(UWORD i = 0; i < EPD_WIDTH / 8 * EPD_HEIGHT; i++) {
        EPD_SendData(0xFF);  // All white
    }
    
    EPD_SendCommand(0x13);  // Red buffer  
    for(UWORD i = 0; i < EPD_WIDTH / 8 * EPD_HEIGHT; i++) {
        EPD_SendData(0x00);  // All white (no red)
    }
    
    EPD_SendCommand(0x10);  // Switch back to black buffer
}

// Arduino setup function
void setup() {
    Serial.begin(115200);
    Serial.println("ESP32 7.5b e-Paper Demo Starting...");
    
    // Initialize SPI and display
    EPD_initSPI();
    
    // Initialize the 7.5b display
    if (EPD_7in5B_V2_Init() == 0) {
        Serial.println("Display initialized successfully");
    } else {
        Serial.println("Display initialization failed");
        return;
    }
    
    // Clear display (white background)
    clearDisplay();
    
    // For this demo, we'll create a simple pattern to demonstrate the display works
    // In a real application, you would draw actual text or images
    
    // Create a simple border pattern to show the display is working
    EPD_SendCommand(0x10);  // Switch to black buffer
    
    // Draw a simple border around the display
    for(UWORD i = 0; i < EPD_WIDTH / 8 * EPD_HEIGHT; i++) {
        // Create a simple pattern: border pixels are black, center is white
        int x = (i * 8) % EPD_WIDTH;
        int y = (i * 8) / EPD_WIDTH;
        
        if (x < 20 || x > EPD_WIDTH - 20 || y < 20 || y > EPD_HEIGHT - 20) {
            EPD_SendData(0x00);  // Black border
        } else {
            EPD_SendData(0xFF);  // White center
        }
    }
    
    // Refresh display to show the pattern
    EPD_7IN5_V2_Show();
    
    Serial.println("Demo completed - display should show a black border with white center");
    Serial.println("Display entering sleep mode");
}

// Arduino loop function
void loop() {
    // Nothing to do here - display maintains image without power
    delay(1000);
}
